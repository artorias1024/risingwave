# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- id: create_tables
  sql: |
    CREATE TABLE supplier (
            s_suppkey  INTEGER,
            s_name VARCHAR,
            s_address VARCHAR,
            s_nationkey INTEGER,
            s_phone VARCHAR,
            s_acctbal NUMERIC,
            s_comment VARCHAR,
            PRIMARY KEY (s_suppkey)
    );

    CREATE TABLE part (
            p_partkey INTEGER,
            p_name VARCHAR,
            p_mfgr VARCHAR,
            p_brand VARCHAR,
            p_type VARCHAR,
            p_size INTEGER,
            p_container VARCHAR,
            p_retailprice NUMERIC,
            p_comment VARCHAR,
            PRIMARY KEY (p_partkey)
    );

    CREATE TABLE partsupp (
            ps_partkey INTEGER,
            ps_suppkey INTEGER,
            ps_availqty INTEGER,
            ps_supplycost NUMERIC,
            ps_comment VARCHAR,
            PRIMARY KEY (ps_partkey, ps_suppkey)
    );

    CREATE TABLE customer (
            c_custkey INTEGER,
            c_name VARCHAR,
            c_address VARCHAR,
            c_nationkey INTEGER,
            c_phone VARCHAR,
            c_acctbal NUMERIC,
            c_mktsegment VARCHAR,
            c_comment VARCHAR,
            PRIMARY KEY (c_custkey)
    );

    CREATE TABLE orders (
            o_orderkey BIGINT,
            o_custkey INTEGER,
            o_orderstatus VARCHAR,
            o_totalprice NUMERIC,
            o_orderdate DATE,
            o_orderpriority VARCHAR,
            o_clerk VARCHAR,
            o_shippriority INTEGER,
            o_comment VARCHAR,
            PRIMARY KEY (o_orderkey)
    );

    CREATE TABLE lineitem (
            l_orderkey BIGINT,
            l_partkey INTEGER,
            l_suppkey INTEGER,
            l_linenumber INTEGER,
            l_quantity NUMERIC,
            l_extendedprice NUMERIC,
            l_discount NUMERIC,
            l_tax NUMERIC,
            l_returnflag VARCHAR,
            l_linestatus VARCHAR,
            l_shipdate DATE,
            l_commitdate DATE,
            l_receiptdate DATE,
            l_shipinstruct VARCHAR,
            l_shipmode VARCHAR,
            l_comment VARCHAR,
            PRIMARY KEY (l_orderkey, l_linenumber)
    );

    CREATE TABLE nation (
            n_nationkey INTEGER,
            n_name VARCHAR,
            n_regionkey INTEGER,
            n_comment VARCHAR,
            PRIMARY KEY (n_nationkey)
    );

    CREATE TABLE region (
            r_regionkey INTEGER,
            r_name VARCHAR,
            r_comment VARCHAR,
            PRIMARY KEY (r_regionkey)
    );
- id: tpch_q2
  before:
  - create_tables
  sql: |
    select
        s_acctbal,
        s_name,
        n_name,
        p_partkey,
        p_mfgr,
        s_address,
        s_phone,
        s_comment
    from
        part,
        supplier,
        partsupp,
        nation,
        region
    where
        p_partkey = ps_partkey
        and s_suppkey = ps_suppkey
        and p_size = 4
        and p_type like '%TIN'
        and s_nationkey = n_nationkey
        and n_regionkey = r_regionkey
        and r_name = 'AFRICA'
        and ps_supplycost = (
                select
                        min(ps_supplycost)
                from
                        partsupp,
                        supplier,
                        nation,
                        region
                where
                        p_partkey = ps_partkey
                        and s_suppkey = ps_suppkey
                        and s_nationkey = n_nationkey
                        and n_regionkey = r_regionkey
                        and r_name = 'AFRICA'
        )
    order by
        s_acctbal desc,
        n_name,
        s_name,
        p_partkey
    limit 100;
  stream_plan: |
    StreamMaterialize { columns: [s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment, region.r_regionkey(hidden), nation.n_nationkey(hidden), supplier.s_suppkey(hidden), part.p_partkey(hidden), partsupp.ps_partkey(hidden), partsupp.ps_suppkey(hidden), min(partsupp.ps_supplycost)(hidden)], stream_key: [region.r_regionkey, nation.n_nationkey, supplier.s_suppkey, part.p_partkey, p_partkey, partsupp.ps_partkey, partsupp.ps_suppkey, min(partsupp.ps_supplycost)], pk_columns: [s_acctbal, n_name, s_name, p_partkey, region.r_regionkey, nation.n_nationkey, supplier.s_suppkey, part.p_partkey, partsupp.ps_partkey, partsupp.ps_suppkey, min(partsupp.ps_supplycost)], pk_conflict: "NoCheck" }
    └─StreamProject { exprs: [supplier.s_acctbal, supplier.s_name, nation.n_name, part.p_partkey, part.p_mfgr, supplier.s_address, supplier.s_phone, supplier.s_comment, region.r_regionkey, nation.n_nationkey, supplier.s_suppkey, part.p_partkey, partsupp.ps_partkey, partsupp.ps_suppkey, min(partsupp.ps_supplycost)] }
      └─StreamTopN { order: "[supplier.s_acctbal DESC, nation.n_name ASC, supplier.s_name ASC, part.p_partkey ASC]", limit: 100, offset: 0 }
        └─StreamExchange { dist: Single }
          └─StreamGroupTopN { order: "[supplier.s_acctbal DESC, nation.n_name ASC, supplier.s_name ASC, part.p_partkey ASC]", limit: 100, offset: 0, group_key: [15] }
            └─StreamProject { exprs: [supplier.s_acctbal, supplier.s_name, nation.n_name, part.p_partkey, part.p_mfgr, supplier.s_address, supplier.s_phone, supplier.s_comment, region.r_regionkey, nation.n_nationkey, supplier.s_suppkey, part.p_partkey, partsupp.ps_partkey, partsupp.ps_suppkey, min(partsupp.ps_supplycost), Vnode(supplier.s_suppkey) as $expr1] }
              └─StreamHashJoin { type: Inner, predicate: supplier.s_suppkey = partsupp.ps_suppkey, output: [supplier.s_acctbal, supplier.s_name, nation.n_name, part.p_partkey, part.p_mfgr, supplier.s_address, supplier.s_phone, supplier.s_comment, region.r_regionkey, nation.n_nationkey, supplier.s_suppkey, part.p_partkey, partsupp.ps_partkey, partsupp.ps_suppkey, min(partsupp.ps_supplycost)] }
                ├─StreamExchange { dist: HashShard(supplier.s_suppkey) }
                | └─StreamHashJoin { type: Inner, predicate: nation.n_nationkey = supplier.s_nationkey, output: [nation.n_name, supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_phone, supplier.s_acctbal, supplier.s_comment, region.r_regionkey, nation.n_nationkey] }
                |   ├─StreamExchange { dist: HashShard(nation.n_nationkey) }
                |   | └─StreamHashJoin { type: Inner, predicate: region.r_regionkey = nation.n_regionkey, output: [nation.n_nationkey, nation.n_name, region.r_regionkey] }
                |   |   ├─StreamExchange { dist: HashShard(region.r_regionkey) }
                |   |   | └─StreamProject { exprs: [region.r_regionkey] }
                |   |   |   └─StreamFilter { predicate: (region.r_name = 'AFRICA':Varchar) }
                |   |   |     └─StreamTableScan { table: region, columns: [region.r_regionkey, region.r_name], pk: [region.r_regionkey], dist: UpstreamHashShard(region.r_regionkey) }
                |   |   └─StreamExchange { dist: HashShard(nation.n_regionkey) }
                |   |     └─StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_name, nation.n_regionkey], pk: [nation.n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) }
                |   └─StreamExchange { dist: HashShard(supplier.s_nationkey) }
                |     └─StreamTableScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_nationkey, supplier.s_phone, supplier.s_acctbal, supplier.s_comment], pk: [supplier.s_suppkey], dist: UpstreamHashShard(supplier.s_suppkey) }
                └─StreamExchange { dist: HashShard(partsupp.ps_suppkey) }
                  └─StreamHashJoin { type: Inner, predicate: part.p_partkey IS NOT DISTINCT FROM part.p_partkey AND min(partsupp.ps_supplycost) = partsupp.ps_supplycost, output: [part.p_partkey, part.p_mfgr, partsupp.ps_suppkey, part.p_partkey, min(partsupp.ps_supplycost), partsupp.ps_partkey] }
                    ├─StreamProject { exprs: [part.p_partkey, min(partsupp.ps_supplycost)] }
                    | └─StreamHashAgg { group_key: [part.p_partkey], aggs: [min(partsupp.ps_supplycost), count] }
                    |   └─StreamHashJoin { type: LeftOuter, predicate: part.p_partkey IS NOT DISTINCT FROM partsupp.ps_partkey, output: [part.p_partkey, partsupp.ps_supplycost, partsupp.ps_partkey, partsupp.ps_suppkey, supplier.s_suppkey, region.r_regionkey, nation.n_nationkey, supplier.s_nationkey] }
                    |     ├─StreamExchange { dist: HashShard(part.p_partkey) }
                    |     | └─StreamProject { exprs: [part.p_partkey] }
                    |     |   └─StreamHashAgg { group_key: [part.p_partkey], aggs: [count] }
                    |     |     └─StreamProject { exprs: [part.p_partkey] }
                    |     |       └─StreamFilter { predicate: (part.p_size = 4:Int32) AND Like(part.p_type, '%TIN':Varchar) }
                    |     |         └─StreamTableScan { table: part, columns: [part.p_partkey, part.p_type, part.p_size], pk: [part.p_partkey], dist: UpstreamHashShard(part.p_partkey) }
                    |     └─StreamExchange { dist: HashShard(partsupp.ps_partkey) }
                    |       └─StreamHashJoin { type: Inner, predicate: supplier.s_nationkey = nation.n_nationkey, output: [partsupp.ps_partkey, partsupp.ps_supplycost, partsupp.ps_suppkey, supplier.s_suppkey, supplier.s_nationkey, region.r_regionkey, nation.n_nationkey] }
                    |         ├─StreamExchange { dist: HashShard(supplier.s_nationkey) }
                    |         | └─StreamHashJoin { type: Inner, predicate: partsupp.ps_suppkey = supplier.s_suppkey, output: [partsupp.ps_partkey, partsupp.ps_supplycost, supplier.s_nationkey, partsupp.ps_suppkey, supplier.s_suppkey] }
                    |         |   ├─StreamExchange { dist: HashShard(partsupp.ps_suppkey) }
                    |         |   | └─StreamFilter { predicate: IsNotNull(partsupp.ps_partkey) }
                    |         |   |   └─StreamTableScan { table: partsupp, columns: [partsupp.ps_partkey, partsupp.ps_suppkey, partsupp.ps_supplycost], pk: [partsupp.ps_partkey, partsupp.ps_suppkey], dist: UpstreamHashShard(partsupp.ps_partkey, partsupp.ps_suppkey) }
                    |         |   └─StreamExchange { dist: HashShard(supplier.s_suppkey) }
                    |         |     └─StreamTableScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_nationkey], pk: [supplier.s_suppkey], dist: UpstreamHashShard(supplier.s_suppkey) }
                    |         └─StreamExchange { dist: HashShard(nation.n_nationkey) }
                    |           └─StreamHashJoin { type: Inner, predicate: region.r_regionkey = nation.n_regionkey, output: [nation.n_nationkey, region.r_regionkey] }
                    |             ├─StreamExchange { dist: HashShard(region.r_regionkey) }
                    |             | └─StreamProject { exprs: [region.r_regionkey] }
                    |             |   └─StreamFilter { predicate: (region.r_name = 'AFRICA':Varchar) }
                    |             |     └─StreamTableScan { table: region, columns: [region.r_regionkey, region.r_name], pk: [region.r_regionkey], dist: UpstreamHashShard(region.r_regionkey) }
                    |             └─StreamExchange { dist: HashShard(nation.n_regionkey) }
                    |               └─StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_regionkey], pk: [nation.n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) }
                    └─StreamHashJoin { type: Inner, predicate: part.p_partkey = partsupp.ps_partkey, output: [part.p_partkey, part.p_mfgr, partsupp.ps_suppkey, partsupp.ps_supplycost, partsupp.ps_partkey] }
                      ├─StreamExchange { dist: HashShard(part.p_partkey) }
                      | └─StreamProject { exprs: [part.p_partkey, part.p_mfgr] }
                      |   └─StreamFilter { predicate: (part.p_size = 4:Int32) AND Like(part.p_type, '%TIN':Varchar) }
                      |     └─StreamTableScan { table: part, columns: [part.p_partkey, part.p_mfgr, part.p_type, part.p_size], pk: [part.p_partkey], dist: UpstreamHashShard(part.p_partkey) }
                      └─StreamExchange { dist: HashShard(partsupp.ps_partkey) }
                        └─StreamTableScan { table: partsupp, columns: [partsupp.ps_partkey, partsupp.ps_suppkey, partsupp.ps_supplycost], pk: [partsupp.ps_partkey, partsupp.ps_suppkey], dist: UpstreamHashShard(partsupp.ps_partkey, partsupp.ps_suppkey) }
  with_config_map:
    RW_STREAMING_ENABLE_BUSHY_JOIN: 'true'
- id: tpch_q5
  before:
  - create_tables
  sql: |
    select
      n_name,
      sum(l_extendedprice * (1 - l_discount)) as revenue
    from
      customer,
      orders,
      lineitem,
      supplier,
      nation,
      region
    where
      c_custkey = o_custkey
      and l_orderkey = o_orderkey
      and l_suppkey = s_suppkey
      and c_nationkey = s_nationkey
      and s_nationkey = n_nationkey
      and n_regionkey = r_regionkey
      and r_name = 'MIDDLE EAST'
      and o_orderdate >= date '1994-01-01'
      and o_orderdate < date '1994-01-01' + interval '1' year
    group by
      n_name
    order by
      revenue desc;
  stream_plan: |
    StreamMaterialize { columns: [n_name, revenue], stream_key: [n_name], pk_columns: [revenue, n_name], pk_conflict: "NoCheck" }
    └─StreamProject { exprs: [nation.n_name, sum($expr1)] }
      └─StreamHashAgg { group_key: [nation.n_name], aggs: [sum($expr1), count] }
        └─StreamExchange { dist: HashShard(nation.n_name) }
          └─StreamProject { exprs: [nation.n_name, (lineitem.l_extendedprice * (1:Decimal - lineitem.l_discount)) as $expr1, lineitem.l_orderkey, lineitem.l_linenumber, supplier.s_suppkey, lineitem.l_suppkey, region.r_regionkey, nation.n_nationkey, orders.o_orderkey, customer.c_custkey, orders.o_custkey, supplier.s_nationkey] }
            └─StreamHashJoin { type: Inner, predicate: lineitem.l_orderkey = orders.o_orderkey AND supplier.s_nationkey = customer.c_nationkey AND supplier.s_nationkey = nation.n_nationkey, output: [lineitem.l_extendedprice, lineitem.l_discount, nation.n_name, lineitem.l_orderkey, lineitem.l_linenumber, supplier.s_suppkey, lineitem.l_suppkey, supplier.s_nationkey, region.r_regionkey, nation.n_nationkey, orders.o_orderkey, customer.c_custkey, orders.o_custkey] }
              ├─StreamExchange { dist: HashShard(supplier.s_nationkey) }
              | └─StreamHashJoin { type: Inner, predicate: lineitem.l_suppkey = supplier.s_suppkey, output: [lineitem.l_orderkey, lineitem.l_extendedprice, lineitem.l_discount, supplier.s_nationkey, lineitem.l_linenumber, lineitem.l_suppkey, supplier.s_suppkey] }
              |   ├─StreamExchange { dist: HashShard(lineitem.l_suppkey) }
              |   | └─StreamTableScan { table: lineitem, columns: [lineitem.l_orderkey, lineitem.l_suppkey, lineitem.l_extendedprice, lineitem.l_discount, lineitem.l_linenumber], pk: [lineitem.l_orderkey, lineitem.l_linenumber], dist: UpstreamHashShard(lineitem.l_orderkey, lineitem.l_linenumber) }
              |   └─StreamExchange { dist: HashShard(supplier.s_suppkey) }
              |     └─StreamFilter { predicate: (supplier.s_nationkey = supplier.s_nationkey) }
              |       └─StreamTableScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_nationkey], pk: [supplier.s_suppkey], dist: UpstreamHashShard(supplier.s_suppkey) }
              └─StreamHashJoin { type: Inner, predicate: nation.n_nationkey = customer.c_nationkey, output: [nation.n_nationkey, nation.n_name, orders.o_orderkey, customer.c_nationkey, region.r_regionkey, customer.c_custkey, orders.o_custkey] }
                ├─StreamExchange { dist: HashShard(nation.n_nationkey) }
                | └─StreamHashJoin { type: Inner, predicate: region.r_regionkey = nation.n_regionkey, output: [nation.n_nationkey, nation.n_name, region.r_regionkey] }
                |   ├─StreamExchange { dist: HashShard(region.r_regionkey) }
                |   | └─StreamProject { exprs: [region.r_regionkey] }
                |   |   └─StreamFilter { predicate: (region.r_name = 'MIDDLE EAST':Varchar) }
                |   |     └─StreamTableScan { table: region, columns: [region.r_regionkey, region.r_name], pk: [region.r_regionkey], dist: UpstreamHashShard(region.r_regionkey) }
                |   └─StreamExchange { dist: HashShard(nation.n_regionkey) }
                |     └─StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_name, nation.n_regionkey], pk: [nation.n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) }
                └─StreamExchange { dist: HashShard(customer.c_nationkey) }
                  └─StreamHashJoin { type: Inner, predicate: orders.o_custkey = customer.c_custkey, output: [orders.o_orderkey, customer.c_nationkey, orders.o_custkey, customer.c_custkey] }
                    ├─StreamExchange { dist: HashShard(orders.o_custkey) }
                    | └─StreamProject { exprs: [orders.o_orderkey, orders.o_custkey] }
                    |   └─StreamFilter { predicate: (orders.o_orderdate >= '1994-01-01':Date) AND (orders.o_orderdate < '1995-01-01 00:00:00':Timestamp) }
                    |     └─StreamTableScan { table: orders, columns: [orders.o_orderkey, orders.o_custkey, orders.o_orderdate], pk: [orders.o_orderkey], dist: UpstreamHashShard(orders.o_orderkey) }
                    └─StreamExchange { dist: HashShard(customer.c_custkey) }
                      └─StreamTableScan { table: customer, columns: [customer.c_custkey, customer.c_nationkey], pk: [customer.c_custkey], dist: UpstreamHashShard(customer.c_custkey) }
  with_config_map:
    RW_STREAMING_ENABLE_BUSHY_JOIN: 'true'
- id: tpch_q7
  before:
  - create_tables
  sql: |
    select
      supp_nation,
      cust_nation,
      l_year,
      sum(volume) as revenue
    from
      (
        select
          n1.n_name as supp_nation,
          n2.n_name as cust_nation,
          extract(year from l_shipdate) as l_year,
          l_extendedprice * (1 - l_discount) as volume
        from
          supplier,
          lineitem,
          orders,
          customer,
          nation n1,
          nation n2
        where
          s_suppkey = l_suppkey
          and o_orderkey = l_orderkey
          and c_custkey = o_custkey
          and s_nationkey = n1.n_nationkey
          and c_nationkey = n2.n_nationkey
          and (
            (n1.n_name = 'ROMANIA' and n2.n_name = 'IRAN')
            or (n1.n_name = 'IRAN' and n2.n_name = 'ROMANIA')
          )
          and l_shipdate between date '1983-01-01' and date '2000-12-31'
      ) as shipping
    group by
      supp_nation,
      cust_nation,
      l_year
    order by
      supp_nation,
      cust_nation,
      l_year;
  stream_plan: |
    StreamMaterialize { columns: [supp_nation, cust_nation, l_year, revenue], stream_key: [supp_nation, cust_nation, l_year], pk_columns: [supp_nation, cust_nation, l_year], pk_conflict: "NoCheck" }
    └─StreamProject { exprs: [nation.n_name, nation.n_name, $expr1, sum($expr2)] }
      └─StreamHashAgg { group_key: [nation.n_name, nation.n_name, $expr1], aggs: [sum($expr2), count] }
        └─StreamExchange { dist: HashShard(nation.n_name, nation.n_name, $expr1) }
          └─StreamProject { exprs: [nation.n_name, nation.n_name, Extract('YEAR':Varchar, lineitem.l_shipdate) as $expr1, (lineitem.l_extendedprice * (1:Decimal - lineitem.l_discount)) as $expr2, nation.n_nationkey, supplier.s_suppkey, lineitem.l_orderkey, lineitem.l_linenumber, nation.n_nationkey, customer.c_custkey, orders.o_orderkey] }
            └─StreamFilter { predicate: (((nation.n_name = 'ROMANIA':Varchar) AND (nation.n_name = 'IRAN':Varchar)) OR ((nation.n_name = 'IRAN':Varchar) AND (nation.n_name = 'ROMANIA':Varchar))) }
              └─StreamHashJoin { type: Inner, predicate: lineitem.l_orderkey = orders.o_orderkey, output: all }
                ├─StreamExchange { dist: HashShard(lineitem.l_orderkey) }
                | └─StreamHashJoin { type: Inner, predicate: supplier.s_suppkey = lineitem.l_suppkey, output: [nation.n_name, lineitem.l_orderkey, lineitem.l_extendedprice, lineitem.l_discount, lineitem.l_shipdate, nation.n_nationkey, supplier.s_suppkey, lineitem.l_linenumber] }
                |   ├─StreamExchange { dist: HashShard(supplier.s_suppkey) }
                |   | └─StreamHashJoin { type: Inner, predicate: nation.n_nationkey = supplier.s_nationkey, output: [nation.n_name, supplier.s_suppkey, nation.n_nationkey] }
                |   |   ├─StreamExchange { dist: HashShard(nation.n_nationkey) }
                |   |   | └─StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_name], pk: [nation.n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) }
                |   |   └─StreamExchange { dist: HashShard(supplier.s_nationkey) }
                |   |     └─StreamTableScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_nationkey], pk: [supplier.s_suppkey], dist: UpstreamHashShard(supplier.s_suppkey) }
                |   └─StreamExchange { dist: HashShard(lineitem.l_suppkey) }
                |     └─StreamFilter { predicate: (lineitem.l_shipdate >= '1983-01-01':Date) AND (lineitem.l_shipdate <= '2000-12-31':Date) }
                |       └─StreamTableScan { table: lineitem, columns: [lineitem.l_orderkey, lineitem.l_suppkey, lineitem.l_extendedprice, lineitem.l_discount, lineitem.l_shipdate, lineitem.l_linenumber], pk: [lineitem.l_orderkey, lineitem.l_linenumber], dist: UpstreamHashShard(lineitem.l_orderkey, lineitem.l_linenumber) }
                └─StreamExchange { dist: HashShard(orders.o_orderkey) }
                  └─StreamHashJoin { type: Inner, predicate: customer.c_custkey = orders.o_custkey, output: [nation.n_name, orders.o_orderkey, nation.n_nationkey, customer.c_custkey] }
                    ├─StreamExchange { dist: HashShard(customer.c_custkey) }
                    | └─StreamHashJoin { type: Inner, predicate: nation.n_nationkey = customer.c_nationkey, output: [nation.n_name, customer.c_custkey, nation.n_nationkey] }
                    |   ├─StreamExchange { dist: HashShard(nation.n_nationkey) }
                    |   | └─StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_name], pk: [nation.n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) }
                    |   └─StreamExchange { dist: HashShard(customer.c_nationkey) }
                    |     └─StreamTableScan { table: customer, columns: [customer.c_custkey, customer.c_nationkey], pk: [customer.c_custkey], dist: UpstreamHashShard(customer.c_custkey) }
                    └─StreamExchange { dist: HashShard(orders.o_custkey) }
                      └─StreamTableScan { table: orders, columns: [orders.o_orderkey, orders.o_custkey], pk: [orders.o_orderkey], dist: UpstreamHashShard(orders.o_orderkey) }
  with_config_map:
    RW_STREAMING_ENABLE_BUSHY_JOIN: 'true'
- id: tpch_q8
  before:
  - create_tables
  sql: |
    select
      o_year,
      round(sum(case
        when nation = 'IRAN' then volume
        else 0
      end) / sum(volume), 6) as mkt_share
    from
      (
        select
          extract(year from o_orderdate) as o_year,
          l_extendedprice * (1 - l_discount) as volume,
          n2.n_name as nation
        from
          part,
          supplier,
          lineitem,
          orders,
          customer,
          nation n1,
          nation n2,
          region
        where
          p_partkey = l_partkey
          and s_suppkey = l_suppkey
          and l_orderkey = o_orderkey
          and o_custkey = c_custkey
          and c_nationkey = n1.n_nationkey
          and n1.n_regionkey = r_regionkey
          and r_name = 'ASIA'
          and s_nationkey = n2.n_nationkey
          and o_orderdate between date '1995-01-01' and date '1996-12-31'
          and p_type = 'PROMO ANODIZED STEEL'
      ) as all_nations
    group by
      o_year
    order by
      o_year;
  stream_plan: |
    StreamMaterialize { columns: [o_year, mkt_share], stream_key: [o_year], pk_columns: [o_year], pk_conflict: "NoCheck" }
    └─StreamProject { exprs: [$expr1, RoundDigit((sum($expr2) / sum($expr3)), 6:Int32) as $expr4] }
      └─StreamHashAgg { group_key: [$expr1], aggs: [sum($expr2), sum($expr3), count] }
        └─StreamExchange { dist: HashShard($expr1) }
          └─StreamProject { exprs: [Extract('YEAR':Varchar, orders.o_orderdate) as $expr1, Case((nation.n_name = 'IRAN':Varchar), (lineitem.l_extendedprice * (1:Decimal - lineitem.l_discount)), 0:Decimal) as $expr2, (lineitem.l_extendedprice * (1:Decimal - lineitem.l_discount)) as $expr3, region.r_regionkey, nation.n_nationkey, customer.c_custkey, nation.n_nationkey, supplier.s_suppkey, part.p_partkey, lineitem.l_orderkey, lineitem.l_linenumber, orders.o_orderkey] }
            └─StreamHashJoin { type: Inner, predicate: customer.c_custkey = orders.o_custkey, output: [lineitem.l_extendedprice, lineitem.l_discount, orders.o_orderdate, nation.n_name, region.r_regionkey, nation.n_nationkey, customer.c_custkey, nation.n_nationkey, supplier.s_suppkey, part.p_partkey, lineitem.l_orderkey, lineitem.l_linenumber, orders.o_orderkey] }
              ├─StreamExchange { dist: HashShard(customer.c_custkey) }
              | └─StreamHashJoin { type: Inner, predicate: nation.n_nationkey = customer.c_nationkey, output: [customer.c_custkey, region.r_regionkey, nation.n_nationkey] }
              |   ├─StreamExchange { dist: HashShard(nation.n_nationkey) }
              |   | └─StreamHashJoin { type: Inner, predicate: region.r_regionkey = nation.n_regionkey, output: [nation.n_nationkey, region.r_regionkey] }
              |   |   ├─StreamExchange { dist: HashShard(region.r_regionkey) }
              |   |   | └─StreamProject { exprs: [region.r_regionkey] }
              |   |   |   └─StreamFilter { predicate: (region.r_name = 'ASIA':Varchar) }
              |   |   |     └─StreamTableScan { table: region, columns: [region.r_regionkey, region.r_name], pk: [region.r_regionkey], dist: UpstreamHashShard(region.r_regionkey) }
              |   |   └─StreamExchange { dist: HashShard(nation.n_regionkey) }
              |   |     └─StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_regionkey], pk: [nation.n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) }
              |   └─StreamExchange { dist: HashShard(customer.c_nationkey) }
              |     └─StreamTableScan { table: customer, columns: [customer.c_custkey, customer.c_nationkey], pk: [customer.c_custkey], dist: UpstreamHashShard(customer.c_custkey) }
              └─StreamExchange { dist: HashShard(orders.o_custkey) }
                └─StreamHashJoin { type: Inner, predicate: lineitem.l_orderkey = orders.o_orderkey, output: [nation.n_name, lineitem.l_extendedprice, lineitem.l_discount, orders.o_custkey, orders.o_orderdate, nation.n_nationkey, supplier.s_suppkey, part.p_partkey, lineitem.l_orderkey, lineitem.l_linenumber, orders.o_orderkey] }
                  ├─StreamExchange { dist: HashShard(lineitem.l_orderkey) }
                  | └─StreamHashJoin { type: Inner, predicate: supplier.s_suppkey = lineitem.l_suppkey, output: [nation.n_name, lineitem.l_orderkey, lineitem.l_extendedprice, lineitem.l_discount, nation.n_nationkey, supplier.s_suppkey, part.p_partkey, lineitem.l_linenumber] }
                  |   ├─StreamExchange { dist: HashShard(supplier.s_suppkey) }
                  |   | └─StreamHashJoin { type: Inner, predicate: nation.n_nationkey = supplier.s_nationkey, output: [nation.n_name, supplier.s_suppkey, nation.n_nationkey] }
                  |   |   ├─StreamExchange { dist: HashShard(nation.n_nationkey) }
                  |   |   | └─StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_name], pk: [nation.n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) }
                  |   |   └─StreamExchange { dist: HashShard(supplier.s_nationkey) }
                  |   |     └─StreamTableScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_nationkey], pk: [supplier.s_suppkey], dist: UpstreamHashShard(supplier.s_suppkey) }
                  |   └─StreamExchange { dist: HashShard(lineitem.l_suppkey) }
                  |     └─StreamHashJoin { type: Inner, predicate: part.p_partkey = lineitem.l_partkey, output: [lineitem.l_orderkey, lineitem.l_suppkey, lineitem.l_extendedprice, lineitem.l_discount, part.p_partkey, lineitem.l_linenumber] }
                  |       ├─StreamExchange { dist: HashShard(part.p_partkey) }
                  |       | └─StreamProject { exprs: [part.p_partkey] }
                  |       |   └─StreamFilter { predicate: (part.p_type = 'PROMO ANODIZED STEEL':Varchar) }
                  |       |     └─StreamTableScan { table: part, columns: [part.p_partkey, part.p_type], pk: [part.p_partkey], dist: UpstreamHashShard(part.p_partkey) }
                  |       └─StreamExchange { dist: HashShard(lineitem.l_partkey) }
                  |         └─StreamTableScan { table: lineitem, columns: [lineitem.l_orderkey, lineitem.l_partkey, lineitem.l_suppkey, lineitem.l_extendedprice, lineitem.l_discount, lineitem.l_linenumber], pk: [lineitem.l_orderkey, lineitem.l_linenumber], dist: UpstreamHashShard(lineitem.l_orderkey, lineitem.l_linenumber) }
                  └─StreamExchange { dist: HashShard(orders.o_orderkey) }
                    └─StreamFilter { predicate: (orders.o_orderdate >= '1995-01-01':Date) AND (orders.o_orderdate <= '1996-12-31':Date) }
                      └─StreamTableScan { table: orders, columns: [orders.o_orderkey, orders.o_custkey, orders.o_orderdate], pk: [orders.o_orderkey], dist: UpstreamHashShard(orders.o_orderkey) }
  with_config_map:
    RW_STREAMING_ENABLE_BUSHY_JOIN: 'true'
- id: tpch_q9
  before:
  - create_tables
  sql: |
    select
      nation,
      o_year,
      round(sum(amount), 2) as sum_profit
    from
      (
        select
          n_name as nation,
          extract(year from o_orderdate) as o_year,
          l_extendedprice * (1 - l_discount) - ps_supplycost * l_quantity as amount
        from
          part,
          supplier,
          lineitem,
          partsupp,
          orders,
          nation
        where
          s_suppkey = l_suppkey
          and ps_suppkey = l_suppkey
          and ps_partkey = l_partkey
          and p_partkey = l_partkey
          and o_orderkey = l_orderkey
          and s_nationkey = n_nationkey
          and p_name like '%yellow%'
      ) as profit
    group by
      nation,
      o_year
    order by
      nation,
      o_year desc;
  stream_plan: |
    StreamMaterialize { columns: [nation, o_year, sum_profit], stream_key: [nation, o_year], pk_columns: [nation, o_year], pk_conflict: "NoCheck" }
    └─StreamProject { exprs: [nation.n_name, $expr1, RoundDigit(sum($expr2), 2:Int32) as $expr3] }
      └─StreamHashAgg { group_key: [nation.n_name, $expr1], aggs: [sum($expr2), count] }
        └─StreamExchange { dist: HashShard(nation.n_name, $expr1) }
          └─StreamProject { exprs: [nation.n_name, Extract('YEAR':Varchar, orders.o_orderdate) as $expr1, ((lineitem.l_extendedprice * (1:Decimal - lineitem.l_discount)) - (partsupp.ps_supplycost * lineitem.l_quantity)) as $expr2, part.p_partkey, partsupp.ps_partkey, partsupp.ps_suppkey, nation.n_nationkey, supplier.s_suppkey, orders.o_orderkey, lineitem.l_orderkey, lineitem.l_linenumber] }
            └─StreamHashJoin { type: Inner, predicate: part.p_partkey = lineitem.l_partkey AND partsupp.ps_suppkey = lineitem.l_suppkey AND partsupp.ps_partkey = lineitem.l_partkey AND partsupp.ps_suppkey = supplier.s_suppkey, output: [lineitem.l_quantity, lineitem.l_extendedprice, lineitem.l_discount, partsupp.ps_supplycost, orders.o_orderdate, nation.n_name, part.p_partkey, partsupp.ps_partkey, partsupp.ps_suppkey, nation.n_nationkey, supplier.s_suppkey, orders.o_orderkey, lineitem.l_orderkey, lineitem.l_linenumber] }
              ├─StreamExchange { dist: HashShard(partsupp.ps_suppkey) }
              | └─StreamHashJoin { type: Inner, predicate: part.p_partkey = partsupp.ps_partkey, output: all }
              |   ├─StreamExchange { dist: HashShard(part.p_partkey) }
              |   | └─StreamProject { exprs: [part.p_partkey] }
              |   |   └─StreamFilter { predicate: Like(part.p_name, '%yellow%':Varchar) }
              |   |     └─StreamTableScan { table: part, columns: [part.p_partkey, part.p_name], pk: [part.p_partkey], dist: UpstreamHashShard(part.p_partkey) }
              |   └─StreamExchange { dist: HashShard(partsupp.ps_partkey) }
              |     └─StreamFilter { predicate: (partsupp.ps_suppkey = partsupp.ps_suppkey) }
              |       └─StreamTableScan { table: partsupp, columns: [partsupp.ps_partkey, partsupp.ps_suppkey, partsupp.ps_supplycost], pk: [partsupp.ps_partkey, partsupp.ps_suppkey], dist: UpstreamHashShard(partsupp.ps_partkey, partsupp.ps_suppkey) }
              └─StreamHashJoin { type: Inner, predicate: supplier.s_suppkey = lineitem.l_suppkey, output: [nation.n_name, supplier.s_suppkey, orders.o_orderdate, lineitem.l_partkey, lineitem.l_suppkey, lineitem.l_quantity, lineitem.l_extendedprice, lineitem.l_discount, nation.n_nationkey, orders.o_orderkey, lineitem.l_orderkey, lineitem.l_linenumber] }
                ├─StreamExchange { dist: HashShard(supplier.s_suppkey) }
                | └─StreamHashJoin { type: Inner, predicate: nation.n_nationkey = supplier.s_nationkey, output: [nation.n_name, supplier.s_suppkey, nation.n_nationkey] }
                |   ├─StreamExchange { dist: HashShard(nation.n_nationkey) }
                |   | └─StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_name], pk: [nation.n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) }
                |   └─StreamExchange { dist: HashShard(supplier.s_nationkey) }
                |     └─StreamTableScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_nationkey], pk: [supplier.s_suppkey], dist: UpstreamHashShard(supplier.s_suppkey) }
                └─StreamExchange { dist: HashShard(lineitem.l_suppkey) }
                  └─StreamHashJoin { type: Inner, predicate: orders.o_orderkey = lineitem.l_orderkey, output: [orders.o_orderdate, lineitem.l_partkey, lineitem.l_suppkey, lineitem.l_quantity, lineitem.l_extendedprice, lineitem.l_discount, orders.o_orderkey, lineitem.l_orderkey, lineitem.l_linenumber] }
                    ├─StreamExchange { dist: HashShard(orders.o_orderkey) }
                    | └─StreamTableScan { table: orders, columns: [orders.o_orderkey, orders.o_orderdate], pk: [orders.o_orderkey], dist: UpstreamHashShard(orders.o_orderkey) }
                    └─StreamExchange { dist: HashShard(lineitem.l_orderkey) }
                      └─StreamFilter { predicate: (lineitem.l_partkey = lineitem.l_partkey) }
                        └─StreamTableScan { table: lineitem, columns: [lineitem.l_orderkey, lineitem.l_partkey, lineitem.l_suppkey, lineitem.l_quantity, lineitem.l_extendedprice, lineitem.l_discount, lineitem.l_linenumber], pk: [lineitem.l_orderkey, lineitem.l_linenumber], dist: UpstreamHashShard(lineitem.l_orderkey, lineitem.l_linenumber) }
  with_config_map:
    RW_STREAMING_ENABLE_BUSHY_JOIN: 'true'
- id: tpch_q10
  before:
  - create_tables
  sql: |
    select
      c_custkey,
      c_name,
      sum(l_extendedprice * (1.00 - l_discount)) as revenue,
      c_acctbal,
      n_name,
      c_address,
      c_phone,
      c_comment
    from
      customer,
      orders,
      lineitem,
      nation
    where
      c_custkey = o_custkey
      and l_orderkey = o_orderkey
      and o_orderdate >= date '1994-01-01'
      and o_orderdate < date '1994-01-01' + interval '3' month
      and l_returnflag = 'R'
      and c_nationkey = n_nationkey
    group by
      c_custkey,
      c_name,
      c_acctbal,
      c_phone,
      n_name,
      c_address,
      c_comment
    order by
      revenue desc
    limit 20;
  stream_plan: |
    StreamMaterialize { columns: [c_custkey, c_name, revenue, c_acctbal, n_name, c_address, c_phone, c_comment], stream_key: [c_custkey, c_name, c_acctbal, c_phone, n_name, c_address, c_comment], pk_columns: [revenue, c_custkey, c_name, c_acctbal, c_phone, n_name, c_address, c_comment], pk_conflict: "NoCheck" }
    └─StreamProject { exprs: [customer.c_custkey, customer.c_name, sum($expr1), customer.c_acctbal, nation.n_name, customer.c_address, customer.c_phone, customer.c_comment] }
      └─StreamTopN { order: "[sum($expr1) DESC]", limit: 20, offset: 0 }
        └─StreamExchange { dist: Single }
          └─StreamGroupTopN { order: "[sum($expr1) DESC]", limit: 20, offset: 0, group_key: [8] }
            └─StreamProject { exprs: [customer.c_custkey, customer.c_name, sum($expr1), customer.c_acctbal, nation.n_name, customer.c_address, customer.c_phone, customer.c_comment, Vnode(customer.c_custkey) as $expr2] }
              └─StreamHashAgg { group_key: [customer.c_custkey, customer.c_name, customer.c_acctbal, customer.c_phone, nation.n_name, customer.c_address, customer.c_comment], aggs: [sum($expr1), count] }
                └─StreamProject { exprs: [customer.c_custkey, customer.c_name, customer.c_acctbal, customer.c_phone, nation.n_name, customer.c_address, customer.c_comment, (lineitem.l_extendedprice * (1.00:Decimal - lineitem.l_discount)) as $expr1, nation.n_nationkey, lineitem.l_orderkey, lineitem.l_linenumber, orders.o_orderkey] }
                  └─StreamHashJoin { type: Inner, predicate: customer.c_custkey = orders.o_custkey, output: [customer.c_custkey, customer.c_name, customer.c_address, customer.c_phone, customer.c_acctbal, customer.c_comment, lineitem.l_extendedprice, lineitem.l_discount, nation.n_name, nation.n_nationkey, lineitem.l_orderkey, lineitem.l_linenumber, orders.o_orderkey] }
                    ├─StreamExchange { dist: HashShard(customer.c_custkey) }
                    | └─StreamHashJoin { type: Inner, predicate: nation.n_nationkey = customer.c_nationkey, output: [nation.n_name, customer.c_custkey, customer.c_name, customer.c_address, customer.c_phone, customer.c_acctbal, customer.c_comment, nation.n_nationkey] }
                    |   ├─StreamExchange { dist: HashShard(nation.n_nationkey) }
                    |   | └─StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_name], pk: [nation.n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) }
                    |   └─StreamExchange { dist: HashShard(customer.c_nationkey) }
                    |     └─StreamTableScan { table: customer, columns: [customer.c_custkey, customer.c_name, customer.c_address, customer.c_nationkey, customer.c_phone, customer.c_acctbal, customer.c_comment], pk: [customer.c_custkey], dist: UpstreamHashShard(customer.c_custkey) }
                    └─StreamExchange { dist: HashShard(orders.o_custkey) }
                      └─StreamHashJoin { type: Inner, predicate: lineitem.l_orderkey = orders.o_orderkey, output: [lineitem.l_extendedprice, lineitem.l_discount, orders.o_custkey, lineitem.l_orderkey, lineitem.l_linenumber, orders.o_orderkey] }
                        ├─StreamExchange { dist: HashShard(lineitem.l_orderkey) }
                        | └─StreamProject { exprs: [lineitem.l_orderkey, lineitem.l_extendedprice, lineitem.l_discount, lineitem.l_linenumber] }
                        |   └─StreamFilter { predicate: (lineitem.l_returnflag = 'R':Varchar) }
                        |     └─StreamTableScan { table: lineitem, columns: [lineitem.l_orderkey, lineitem.l_extendedprice, lineitem.l_discount, lineitem.l_linenumber, lineitem.l_returnflag], pk: [lineitem.l_orderkey, lineitem.l_linenumber], dist: UpstreamHashShard(lineitem.l_orderkey, lineitem.l_linenumber) }
                        └─StreamExchange { dist: HashShard(orders.o_orderkey) }
                          └─StreamProject { exprs: [orders.o_orderkey, orders.o_custkey] }
                            └─StreamFilter { predicate: (orders.o_orderdate >= '1994-01-01':Date) AND (orders.o_orderdate < '1994-04-01 00:00:00':Timestamp) }
                              └─StreamTableScan { table: orders, columns: [orders.o_orderkey, orders.o_custkey, orders.o_orderdate], pk: [orders.o_orderkey], dist: UpstreamHashShard(orders.o_orderkey) }
  with_config_map:
    RW_STREAMING_ENABLE_BUSHY_JOIN: 'true'
- id: tpch_q21
  before:
  - create_tables
  sql: |
    select
      s_name,
      count(*) as numwait
    from
      supplier,
      lineitem l1,
      orders,
      nation
    where
      s_suppkey = l1.l_suppkey
      and o_orderkey = l1.l_orderkey
      and o_orderstatus = 'F'
      and l1.l_receiptdate > l1.l_commitdate
      and exists (
        select
          *
        from
          lineitem l2
        where
          l2.l_orderkey = l1.l_orderkey
          and l2.l_suppkey <> l1.l_suppkey
      )
      and not exists (
        select
          *
        from
          lineitem l3
        where
          l3.l_orderkey = l1.l_orderkey
          and l3.l_suppkey <> l1.l_suppkey
          and l3.l_receiptdate > l3.l_commitdate
      )
      and s_nationkey = n_nationkey
      and n_name = 'GERMANY'
    group by
      s_name
    order by
      numwait desc,
      s_name
    LIMIT 100;
  stream_plan: |
    StreamMaterialize { columns: [s_name, numwait], stream_key: [s_name], pk_columns: [numwait, s_name], pk_conflict: "NoCheck" }
    └─StreamProject { exprs: [supplier.s_name, count] }
      └─StreamTopN { order: "[count DESC, supplier.s_name ASC]", limit: 100, offset: 0 }
        └─StreamExchange { dist: Single }
          └─StreamGroupTopN { order: "[count DESC, supplier.s_name ASC]", limit: 100, offset: 0, group_key: [2] }
            └─StreamProject { exprs: [supplier.s_name, count, Vnode(supplier.s_name) as $expr1] }
              └─StreamHashAgg { group_key: [supplier.s_name], aggs: [count] }
                └─StreamExchange { dist: HashShard(supplier.s_name) }
                  └─StreamHashJoin { type: LeftAnti, predicate: lineitem.l_orderkey = lineitem.l_orderkey AND (lineitem.l_suppkey <> lineitem.l_suppkey), output: [supplier.s_name, nation.n_nationkey, supplier.s_suppkey, orders.o_orderkey, lineitem.l_orderkey, lineitem.l_linenumber] }
                    ├─StreamHashJoin { type: LeftSemi, predicate: lineitem.l_orderkey = lineitem.l_orderkey AND (lineitem.l_suppkey <> lineitem.l_suppkey), output: all }
                    | ├─StreamExchange { dist: HashShard(lineitem.l_orderkey) }
                    | | └─StreamHashJoin { type: Inner, predicate: supplier.s_suppkey = lineitem.l_suppkey, output: [supplier.s_name, lineitem.l_orderkey, lineitem.l_suppkey, nation.n_nationkey, supplier.s_suppkey, orders.o_orderkey, lineitem.l_linenumber] }
                    | |   ├─StreamExchange { dist: HashShard(supplier.s_suppkey) }
                    | |   | └─StreamHashJoin { type: Inner, predicate: nation.n_nationkey = supplier.s_nationkey, output: [supplier.s_suppkey, supplier.s_name, nation.n_nationkey] }
                    | |   |   ├─StreamExchange { dist: HashShard(nation.n_nationkey) }
                    | |   |   | └─StreamProject { exprs: [nation.n_nationkey] }
                    | |   |   |   └─StreamFilter { predicate: (nation.n_name = 'GERMANY':Varchar) }
                    | |   |   |     └─StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_name], pk: [nation.n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) }
                    | |   |   └─StreamExchange { dist: HashShard(supplier.s_nationkey) }
                    | |   |     └─StreamTableScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_name, supplier.s_nationkey], pk: [supplier.s_suppkey], dist: UpstreamHashShard(supplier.s_suppkey) }
                    | |   └─StreamExchange { dist: HashShard(lineitem.l_suppkey) }
                    | |     └─StreamHashJoin { type: Inner, predicate: orders.o_orderkey = lineitem.l_orderkey, output: [lineitem.l_orderkey, lineitem.l_suppkey, orders.o_orderkey, lineitem.l_linenumber] }
                    | |       ├─StreamExchange { dist: HashShard(orders.o_orderkey) }
                    | |       | └─StreamProject { exprs: [orders.o_orderkey] }
                    | |       |   └─StreamFilter { predicate: (orders.o_orderstatus = 'F':Varchar) }
                    | |       |     └─StreamTableScan { table: orders, columns: [orders.o_orderkey, orders.o_orderstatus], pk: [orders.o_orderkey], dist: UpstreamHashShard(orders.o_orderkey) }
                    | |       └─StreamExchange { dist: HashShard(lineitem.l_orderkey) }
                    | |         └─StreamProject { exprs: [lineitem.l_orderkey, lineitem.l_suppkey, lineitem.l_linenumber] }
                    | |           └─StreamFilter { predicate: (lineitem.l_receiptdate > lineitem.l_commitdate) }
                    | |             └─StreamTableScan { table: lineitem, columns: [lineitem.l_orderkey, lineitem.l_suppkey, lineitem.l_linenumber, lineitem.l_commitdate, lineitem.l_receiptdate], pk: [lineitem.l_orderkey, lineitem.l_linenumber], dist: UpstreamHashShard(lineitem.l_orderkey, lineitem.l_linenumber) }
                    | └─StreamExchange { dist: HashShard(lineitem.l_orderkey) }
                    |   └─StreamTableScan { table: lineitem, columns: [lineitem.l_orderkey, lineitem.l_suppkey, lineitem.l_linenumber], pk: [lineitem.l_orderkey, lineitem.l_linenumber], dist: UpstreamHashShard(lineitem.l_orderkey, lineitem.l_linenumber) }
                    └─StreamExchange { dist: HashShard(lineitem.l_orderkey) }
                      └─StreamProject { exprs: [lineitem.l_orderkey, lineitem.l_suppkey, lineitem.l_linenumber] }
                        └─StreamFilter { predicate: (lineitem.l_receiptdate > lineitem.l_commitdate) }
                          └─StreamTableScan { table: lineitem, columns: [lineitem.l_orderkey, lineitem.l_suppkey, lineitem.l_linenumber, lineitem.l_commitdate, lineitem.l_receiptdate], pk: [lineitem.l_orderkey, lineitem.l_linenumber], dist: UpstreamHashShard(lineitem.l_orderkey, lineitem.l_linenumber) }
  with_config_map:
    RW_STREAMING_ENABLE_BUSHY_JOIN: 'true'
- id: large_join
  before:
  - create_tables
  sql: |-
    select s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment from supplier, part, partsupp, customer, orders, lineitem l1, nation, region where s_suppkey = ps_suppkey and p_partkey = ps_partkey and l_partkey = p_partkey and s_nationkey = n_nationkey and n_regionkey = r_regionkey and l_orderkey = o_orderkey and o_custkey = c_custkey and ps_supplycost = ( select min(ps_supplycost) from supplier, part, partsupp, customer, orders, lineitem l2, nation, region where s_suppkey = ps_suppkey and p_partkey = ps_partkey and l_partkey = p_partkey and s_nationkey = n_nationkey and n_regionkey = r_regionkey and l_orderkey = o_orderkey and o_custkey = c_custkey and exists ( select * from lineitem l3 where l3.l_orderkey = l2.l_orderkey and l3.l_suppkey <> l2.l_suppkey ) and not exists ( select * from lineitem l4 where l4.l_orderkey = l2.l_orderkey and l4.l_suppkey <> l2.l_suppkey and l4.l_receiptdate > l4.l_commitdate ) ) and exists ( select * from lineitem l5 where l5.l_orderkey = l1.l_orderkey and l5.l_suppkey <> l1.l_suppkey ) and not exists ( select * from lineitem l6 where l6.l_orderkey = l1.l_orderkey and l6.l_suppkey <> l1.l_suppkey and l6.l_receiptdate > l6.l_commitdate )
    order by s_acctbal desc, n_name, s_name, p_partkey limit 100;
  stream_plan: |
    StreamMaterialize { columns: [s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment, region.r_regionkey(hidden), nation.n_nationkey(hidden), supplier.s_suppkey(hidden), partsupp.ps_partkey(hidden), partsupp.ps_suppkey(hidden), customer.c_custkey(hidden), orders.o_orderkey(hidden), lineitem.l_orderkey(hidden), lineitem.l_linenumber(hidden), partsupp.ps_supplycost(hidden)], stream_key: [region.r_regionkey, nation.n_nationkey, supplier.s_suppkey, partsupp.ps_partkey, partsupp.ps_suppkey, p_partkey, customer.c_custkey, orders.o_orderkey, lineitem.l_orderkey, lineitem.l_linenumber, partsupp.ps_supplycost], pk_columns: [s_acctbal, n_name, s_name, p_partkey, region.r_regionkey, nation.n_nationkey, supplier.s_suppkey, partsupp.ps_partkey, partsupp.ps_suppkey, customer.c_custkey, orders.o_orderkey, lineitem.l_orderkey, lineitem.l_linenumber, partsupp.ps_supplycost], pk_conflict: "NoCheck" }
    └─StreamProject { exprs: [supplier.s_acctbal, supplier.s_name, nation.n_name, part.p_partkey, part.p_mfgr, supplier.s_address, supplier.s_phone, supplier.s_comment, region.r_regionkey, nation.n_nationkey, supplier.s_suppkey, partsupp.ps_partkey, partsupp.ps_suppkey, customer.c_custkey, orders.o_orderkey, lineitem.l_orderkey, lineitem.l_linenumber, partsupp.ps_supplycost] }
      └─StreamTopN { order: "[supplier.s_acctbal DESC, nation.n_name ASC, supplier.s_name ASC, part.p_partkey ASC]", limit: 100, offset: 0 }
        └─StreamExchange { dist: Single }
          └─StreamGroupTopN { order: "[supplier.s_acctbal DESC, nation.n_name ASC, supplier.s_name ASC, part.p_partkey ASC]", limit: 100, offset: 0, group_key: [18] }
            └─StreamProject { exprs: [supplier.s_acctbal, supplier.s_name, nation.n_name, part.p_partkey, part.p_mfgr, supplier.s_address, supplier.s_phone, supplier.s_comment, region.r_regionkey, nation.n_nationkey, supplier.s_suppkey, partsupp.ps_partkey, partsupp.ps_suppkey, customer.c_custkey, orders.o_orderkey, lineitem.l_orderkey, lineitem.l_linenumber, partsupp.ps_supplycost, Vnode(partsupp.ps_supplycost) as $expr2] }
              └─StreamHashJoin { type: Inner, predicate: partsupp.ps_supplycost = min(min(partsupp.ps_supplycost)), output: [supplier.s_acctbal, supplier.s_name, nation.n_name, part.p_partkey, part.p_mfgr, supplier.s_address, supplier.s_phone, supplier.s_comment, region.r_regionkey, nation.n_nationkey, supplier.s_suppkey, partsupp.ps_partkey, partsupp.ps_suppkey, customer.c_custkey, orders.o_orderkey, lineitem.l_orderkey, lineitem.l_linenumber, partsupp.ps_supplycost] }
                ├─StreamExchange { dist: HashShard(partsupp.ps_supplycost) }
                | └─StreamHashJoin { type: LeftAnti, predicate: lineitem.l_orderkey = lineitem.l_orderkey AND (lineitem.l_suppkey <> lineitem.l_suppkey), output: [supplier.s_name, supplier.s_address, supplier.s_phone, supplier.s_acctbal, supplier.s_comment, part.p_partkey, part.p_mfgr, partsupp.ps_supplycost, nation.n_name, region.r_regionkey, nation.n_nationkey, supplier.s_suppkey, partsupp.ps_partkey, partsupp.ps_suppkey, customer.c_custkey, orders.o_orderkey, lineitem.l_orderkey, lineitem.l_linenumber] }
                |   ├─StreamHashJoin { type: LeftSemi, predicate: lineitem.l_orderkey = lineitem.l_orderkey AND (lineitem.l_suppkey <> lineitem.l_suppkey), output: [supplier.s_name, supplier.s_address, supplier.s_phone, supplier.s_acctbal, supplier.s_comment, part.p_partkey, part.p_mfgr, partsupp.ps_supplycost, lineitem.l_orderkey, lineitem.l_suppkey, nation.n_name, region.r_regionkey, nation.n_nationkey, supplier.s_suppkey, partsupp.ps_partkey, partsupp.ps_suppkey, customer.c_custkey, orders.o_orderkey, lineitem.l_linenumber] }
                |   | ├─StreamExchange { dist: HashShard(lineitem.l_orderkey) }
                |   | | └─StreamFilter { predicate: (supplier.s_suppkey = partsupp.ps_suppkey) AND (part.p_partkey = partsupp.ps_partkey) AND (lineitem.l_partkey = part.p_partkey) AND (supplier.s_nationkey = nation.n_nationkey) AND (nation.n_regionkey = region.r_regionkey) AND (lineitem.l_orderkey = orders.o_orderkey) AND (orders.o_custkey = customer.c_custkey) }
                |   | |   └─StreamShare { id = 30 }
                |   | |     └─StreamHashJoin { type: Inner, predicate: partsupp.ps_partkey = part.p_partkey AND partsupp.ps_partkey = lineitem.l_partkey, output: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_nationkey, supplier.s_phone, supplier.s_acctbal, supplier.s_comment, part.p_partkey, part.p_mfgr, partsupp.ps_partkey, partsupp.ps_suppkey, partsupp.ps_supplycost, customer.c_custkey, orders.o_orderkey, orders.o_custkey, lineitem.l_orderkey, lineitem.l_partkey, lineitem.l_suppkey, nation.n_nationkey, nation.n_name, nation.n_regionkey, region.r_regionkey, lineitem.l_linenumber] }
                |   | |       ├─StreamExchange { dist: HashShard(partsupp.ps_partkey) }
                |   | |       | └─StreamHashJoin { type: Inner, predicate: supplier.s_suppkey = partsupp.ps_suppkey, output: all }
                |   | |       |   ├─StreamExchange { dist: HashShard(supplier.s_suppkey) }
                |   | |       |   | └─StreamHashJoin { type: Inner, predicate: nation.n_nationkey = supplier.s_nationkey, output: all }
                |   | |       |   |   ├─StreamExchange { dist: HashShard(nation.n_nationkey) }
                |   | |       |   |   | └─StreamHashJoin { type: Inner, predicate: region.r_regionkey = nation.n_regionkey, output: all }
                |   | |       |   |   |   ├─StreamExchange { dist: HashShard(region.r_regionkey) }
                |   | |       |   |   |   | └─StreamTableScan { table: region, columns: [region.r_regionkey], pk: [region.r_regionkey], dist: UpstreamHashShard(region.r_regionkey) }
                |   | |       |   |   |   └─StreamExchange { dist: HashShard(nation.n_regionkey) }
                |   | |       |   |   |     └─StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_name, nation.n_regionkey], pk: [nation.n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) }
                |   | |       |   |   └─StreamExchange { dist: HashShard(supplier.s_nationkey) }
                |   | |       |   |     └─StreamTableScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_nationkey, supplier.s_phone, supplier.s_acctbal, supplier.s_comment], pk: [supplier.s_suppkey], dist: UpstreamHashShard(supplier.s_suppkey) }
                |   | |       |   └─StreamExchange { dist: HashShard(partsupp.ps_suppkey) }
                |   | |       |     └─StreamFilter { predicate: (partsupp.ps_partkey = partsupp.ps_partkey) }
                |   | |       |       └─StreamTableScan { table: partsupp, columns: [partsupp.ps_partkey, partsupp.ps_suppkey, partsupp.ps_supplycost], pk: [partsupp.ps_partkey, partsupp.ps_suppkey], dist: UpstreamHashShard(partsupp.ps_partkey, partsupp.ps_suppkey) }
                |   | |       └─StreamHashJoin { type: Inner, predicate: part.p_partkey = lineitem.l_partkey, output: all }
                |   | |         ├─StreamExchange { dist: HashShard(part.p_partkey) }
                |   | |         | └─StreamTableScan { table: part, columns: [part.p_partkey, part.p_mfgr], pk: [part.p_partkey], dist: UpstreamHashShard(part.p_partkey) }
                |   | |         └─StreamExchange { dist: HashShard(lineitem.l_partkey) }
                |   | |           └─StreamHashJoin { type: Inner, predicate: orders.o_orderkey = lineitem.l_orderkey, output: all }
                |   | |             ├─StreamExchange { dist: HashShard(orders.o_orderkey) }
                |   | |             | └─StreamHashJoin { type: Inner, predicate: customer.c_custkey = orders.o_custkey, output: all }
                |   | |             |   ├─StreamExchange { dist: HashShard(customer.c_custkey) }
                |   | |             |   | └─StreamTableScan { table: customer, columns: [customer.c_custkey], pk: [customer.c_custkey], dist: UpstreamHashShard(customer.c_custkey) }
                |   | |             |   └─StreamExchange { dist: HashShard(orders.o_custkey) }
                |   | |             |     └─StreamTableScan { table: orders, columns: [orders.o_orderkey, orders.o_custkey], pk: [orders.o_orderkey], dist: UpstreamHashShard(orders.o_orderkey) }
                |   | |             └─StreamExchange { dist: HashShard(lineitem.l_orderkey) }
                |   | |               └─StreamTableScan { table: lineitem, columns: [lineitem.l_orderkey, lineitem.l_partkey, lineitem.l_suppkey, lineitem.l_linenumber], pk: [lineitem.l_orderkey, lineitem.l_linenumber], dist: UpstreamHashShard(lineitem.l_orderkey, lineitem.l_linenumber) }
                |   | └─StreamExchange { dist: HashShard(lineitem.l_orderkey) }
                |   |   └─StreamTableScan { table: lineitem, columns: [lineitem.l_orderkey, lineitem.l_suppkey, lineitem.l_linenumber], pk: [lineitem.l_orderkey, lineitem.l_linenumber], dist: UpstreamHashShard(lineitem.l_orderkey, lineitem.l_linenumber) }
                |   └─StreamExchange { dist: HashShard(lineitem.l_orderkey) }
                |     └─StreamProject { exprs: [lineitem.l_orderkey, lineitem.l_suppkey, lineitem.l_linenumber] }
                |       └─StreamFilter { predicate: (lineitem.l_receiptdate > lineitem.l_commitdate) }
                |         └─StreamTableScan { table: lineitem, columns: [lineitem.l_orderkey, lineitem.l_suppkey, lineitem.l_linenumber, lineitem.l_commitdate, lineitem.l_receiptdate], pk: [lineitem.l_orderkey, lineitem.l_linenumber], dist: UpstreamHashShard(lineitem.l_orderkey, lineitem.l_linenumber) }
                └─StreamExchange { dist: HashShard(min(min(partsupp.ps_supplycost))) }
                  └─StreamProject { exprs: [min(min(partsupp.ps_supplycost))] }
                    └─StreamGlobalSimpleAgg { aggs: [min(min(partsupp.ps_supplycost)), count] }
                      └─StreamExchange { dist: Single }
                        └─StreamHashAgg { group_key: [$expr1], aggs: [min(partsupp.ps_supplycost), count] }
                          └─StreamProject { exprs: [partsupp.ps_supplycost, region.r_regionkey, nation.n_nationkey, supplier.s_suppkey, partsupp.ps_partkey, partsupp.ps_suppkey, part.p_partkey, customer.c_custkey, orders.o_orderkey, lineitem.l_orderkey, lineitem.l_linenumber, Vnode(lineitem.l_orderkey) as $expr1] }
                            └─StreamHashJoin { type: LeftAnti, predicate: lineitem.l_orderkey = lineitem.l_orderkey AND (lineitem.l_suppkey <> lineitem.l_suppkey), output: [partsupp.ps_supplycost, region.r_regionkey, nation.n_nationkey, supplier.s_suppkey, partsupp.ps_partkey, partsupp.ps_suppkey, part.p_partkey, customer.c_custkey, orders.o_orderkey, lineitem.l_orderkey, lineitem.l_linenumber] }
                              ├─StreamHashJoin { type: LeftSemi, predicate: lineitem.l_orderkey = lineitem.l_orderkey AND (lineitem.l_suppkey <> lineitem.l_suppkey), output: [partsupp.ps_supplycost, lineitem.l_orderkey, lineitem.l_suppkey, region.r_regionkey, nation.n_nationkey, supplier.s_suppkey, partsupp.ps_partkey, partsupp.ps_suppkey, part.p_partkey, customer.c_custkey, orders.o_orderkey, lineitem.l_linenumber] }
                              | ├─StreamExchange { dist: HashShard(lineitem.l_orderkey) }
                              | | └─StreamFilter { predicate: (supplier.s_suppkey = partsupp.ps_suppkey) AND (part.p_partkey = partsupp.ps_partkey) AND (lineitem.l_partkey = part.p_partkey) AND (supplier.s_nationkey = nation.n_nationkey) AND (nation.n_regionkey = region.r_regionkey) AND (lineitem.l_orderkey = orders.o_orderkey) AND (orders.o_custkey = customer.c_custkey) }
                              | |   └─StreamShare { id = 30 }
                              | |     └─StreamHashJoin { type: Inner, predicate: partsupp.ps_partkey = part.p_partkey AND partsupp.ps_partkey = lineitem.l_partkey, output: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_nationkey, supplier.s_phone, supplier.s_acctbal, supplier.s_comment, part.p_partkey, part.p_mfgr, partsupp.ps_partkey, partsupp.ps_suppkey, partsupp.ps_supplycost, customer.c_custkey, orders.o_orderkey, orders.o_custkey, lineitem.l_orderkey, lineitem.l_partkey, lineitem.l_suppkey, nation.n_nationkey, nation.n_name, nation.n_regionkey, region.r_regionkey, lineitem.l_linenumber] }
                              | |       ├─StreamExchange { dist: HashShard(partsupp.ps_partkey) }
                              | |       | └─StreamHashJoin { type: Inner, predicate: supplier.s_suppkey = partsupp.ps_suppkey, output: all }
                              | |       |   ├─StreamExchange { dist: HashShard(supplier.s_suppkey) }
                              | |       |   | └─StreamHashJoin { type: Inner, predicate: nation.n_nationkey = supplier.s_nationkey, output: all }
                              | |       |   |   ├─StreamExchange { dist: HashShard(nation.n_nationkey) }
                              | |       |   |   | └─StreamHashJoin { type: Inner, predicate: region.r_regionkey = nation.n_regionkey, output: all }
                              | |       |   |   |   ├─StreamExchange { dist: HashShard(region.r_regionkey) }
                              | |       |   |   |   | └─StreamTableScan { table: region, columns: [region.r_regionkey], pk: [region.r_regionkey], dist: UpstreamHashShard(region.r_regionkey) }
                              | |       |   |   |   └─StreamExchange { dist: HashShard(nation.n_regionkey) }
                              | |       |   |   |     └─StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_name, nation.n_regionkey], pk: [nation.n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) }
                              | |       |   |   └─StreamExchange { dist: HashShard(supplier.s_nationkey) }
                              | |       |   |     └─StreamTableScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_nationkey, supplier.s_phone, supplier.s_acctbal, supplier.s_comment], pk: [supplier.s_suppkey], dist: UpstreamHashShard(supplier.s_suppkey) }
                              | |       |   └─StreamExchange { dist: HashShard(partsupp.ps_suppkey) }
                              | |       |     └─StreamFilter { predicate: (partsupp.ps_partkey = partsupp.ps_partkey) }
                              | |       |       └─StreamTableScan { table: partsupp, columns: [partsupp.ps_partkey, partsupp.ps_suppkey, partsupp.ps_supplycost], pk: [partsupp.ps_partkey, partsupp.ps_suppkey], dist: UpstreamHashShard(partsupp.ps_partkey, partsupp.ps_suppkey) }
                              | |       └─StreamHashJoin { type: Inner, predicate: part.p_partkey = lineitem.l_partkey, output: all }
                              | |         ├─StreamExchange { dist: HashShard(part.p_partkey) }
                              | |         | └─StreamTableScan { table: part, columns: [part.p_partkey, part.p_mfgr], pk: [part.p_partkey], dist: UpstreamHashShard(part.p_partkey) }
                              | |         └─StreamExchange { dist: HashShard(lineitem.l_partkey) }
                              | |           └─StreamHashJoin { type: Inner, predicate: orders.o_orderkey = lineitem.l_orderkey, output: all }
                              | |             ├─StreamExchange { dist: HashShard(orders.o_orderkey) }
                              | |             | └─StreamHashJoin { type: Inner, predicate: customer.c_custkey = orders.o_custkey, output: all }
                              | |             |   ├─StreamExchange { dist: HashShard(customer.c_custkey) }
                              | |             |   | └─StreamTableScan { table: customer, columns: [customer.c_custkey], pk: [customer.c_custkey], dist: UpstreamHashShard(customer.c_custkey) }
                              | |             |   └─StreamExchange { dist: HashShard(orders.o_custkey) }
                              | |             |     └─StreamTableScan { table: orders, columns: [orders.o_orderkey, orders.o_custkey], pk: [orders.o_orderkey], dist: UpstreamHashShard(orders.o_orderkey) }
                              | |             └─StreamExchange { dist: HashShard(lineitem.l_orderkey) }
                              | |               └─StreamTableScan { table: lineitem, columns: [lineitem.l_orderkey, lineitem.l_partkey, lineitem.l_suppkey, lineitem.l_linenumber], pk: [lineitem.l_orderkey, lineitem.l_linenumber], dist: UpstreamHashShard(lineitem.l_orderkey, lineitem.l_linenumber) }
                              | └─StreamExchange { dist: HashShard(lineitem.l_orderkey) }
                              |   └─StreamTableScan { table: lineitem, columns: [lineitem.l_orderkey, lineitem.l_suppkey, lineitem.l_linenumber], pk: [lineitem.l_orderkey, lineitem.l_linenumber], dist: UpstreamHashShard(lineitem.l_orderkey, lineitem.l_linenumber) }
                              └─StreamExchange { dist: HashShard(lineitem.l_orderkey) }
                                └─StreamProject { exprs: [lineitem.l_orderkey, lineitem.l_suppkey, lineitem.l_linenumber] }
                                  └─StreamFilter { predicate: (lineitem.l_receiptdate > lineitem.l_commitdate) }
                                    └─StreamTableScan { table: lineitem, columns: [lineitem.l_orderkey, lineitem.l_suppkey, lineitem.l_linenumber, lineitem.l_commitdate, lineitem.l_receiptdate], pk: [lineitem.l_orderkey, lineitem.l_linenumber], dist: UpstreamHashShard(lineitem.l_orderkey, lineitem.l_linenumber) }
  with_config_map:
    RW_STREAMING_ENABLE_BUSHY_JOIN: 'true'
